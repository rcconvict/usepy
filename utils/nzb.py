#!/usr/bin/env python
import db, site, category
import gzip, os

def escapeChars(text):
	s = text.replace('&', '&amp;')
	s = s.replace('"', '&#039;')
	s = s.replace("'", '&#039;')
	s = s.replace('<', '&lt;')
	s = s.replace('>', '&gt;')
	return unicode(s, 'utf-8')

class NZB():
	def writeNZBforReleaseID(self, relid, relguid, name, catId, path, printoutput = False):
		if relid == '' or relguid == '' or path == '':
			return False

		mdb = db.DB()
		binaries = dict()
		cat = category.Category()
		catrow = cat.getById(catId)
		site = site.Sites()

		fh = gzip.open(path)
		if fh:
			fh.write('<?xml version="1.0" encoding="UTF-8"?>\n')
			fh.write('<!DOCTYPE nzb PUBLIC "-//newzBin//DTD NZB 1.1//EN" "http://www.newzbin.com/DTD/nzb/nzb-1.1.dtd">\n')
			fh.write('<nzb xmlns="http://www.newzbin.com/DTD/2003/nzb">\n\n')
			fh.write('<head>\n')
			if catrow:
				fh.write(' <meta type="category" %s </meta>\n' % escapeChars(catrow['title']))
			if name != '':
				fh.write(' <meta type="name"> %s </meta>\n' % escapeChars(name))
			fh.write('</head>\n\n')

			result = mdb.query("SELECT collections.*, UNIX_TIMESTAMP(date) AS unixdate, groups.name as groupname FROM collections inner join groups on collections.groupID = groups.ID WHERE collections.releaseID = %s", (relid,))
			for binrow in result:
				result2 = mdb.queryDirect("SELECT ID, name, totalParts from binaries where collectionID = %s", (binrow['ID'],))
				for binrow2 in result2:
					fh.write('<file poster="%s" date="%s" subject="%s (1/%d)"\>\n' % (escapeChars(binrow['fromname']), escapeChars(binrow['unixdate']), escapeChars(binrow2['name']), binrow2['totalParts']))
					fh.write(' <groups>\n')
					fh.write('  <group>%s</group>\n' % binrow['groupname'])
					fh.write(' </groups>\n')
					fh.write(' <segments>\n')

					resparts = mdb.queryDirect("SELECT DISTINCT(messageID), size, partnumber FROM parts WHERE binaryID = %s ORDER BY partnumber", (binrow2['ID'],))
					for partsrow in resparts:
						fh.write('  <segment bytes="%d" number="%d"></segment>\n' % (partsrow['size'], partsrow['partnumber'], escapeChars(partsrow['messageID'])))
					fh.write(' </segments>\n</file>\n')
			fh.write('<!-- generated by usepy -->\n</nzb>')
			fh.close()
			if os.path.isfile(path):
				os.chmod(path, 0777)
			else:
				print '%s does not exist' % path
		else:
			return False

	def copyNZBforImport(self, relguid, nzb, printoutput=False):
		page = page.Page()
		path = self.getNZBPath(relguid, page.site.nzbpath, true, page.site.nzbsplitlevel)
		if os.path.isfile(path):
			print 'ERROR: NZB already exists?'
			return False
			fh = gzip.open(path, 'wb')
			nzbFh = open(nzb)
			data = nzbFh.read()
			nzbFh.close()
			fh.write(data)
			os.chmod(path, 0764)
			fh.close()
			return True

	def buildNZBPath(self, releaseGuid, sitenzbpath = '', createIfDoesntExist = False, levelsToSplit = 1):
		if sitenzbpath == '':
			s = site.Sites()
			data = s.get()
			sitenzbpath = data['nzbpath']
			levelsToSplit = data['nzbsplitlevel']

		subpath = ''

		for i in xrange(len(levelsToSplit)):
			subpath += releaseGuid[i] + '/'

		nzbpath = sitenzbpath + subpath

		if createIfDoesntExist and not os.path.isdir(nzbpath):
			os.mkdir(nzbpath, 0777)

		return nzbpath
			
	# builds a full path to the nzb file on disk. nzbs are stored in a subdir of their first char
	def getNZBPath(self, releaseGuid, sitenzbpath = '', createIfDoesntExist = False, levelsToSplit = 1):
		nzbpath = self.buildNZBPath(releaseGuid, sitenzbpath, createIfDoesntExist, levelsToSplit)
		return nzbpath+releaseGuid+'.nzb.gz'

	# check if the NZB is there, returns path, else false.
	def NZBPath(self, releaseGuid, sitenzbpath = '', levelsToSplit = 1):
		nzbfile = self.getNZBPath(releaseGuid, sitenzbpath, False, levelsToSplit)
		return False if not os.path.isfile(nzbfile) else nzbfile

	def nzbFileList(self, nzb):
		result = dict()

		nzb = nzb.replace('\x0F', '')
		num_pars = 0
		# just finish xml parsing later
